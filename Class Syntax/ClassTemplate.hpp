// Проектировние класса (в C++) делится на два файла:
// ClassName.hpp - интерфейс класса. В нем описаны:
// 										1. поля класса (переменные);
//										2. заголовки конструкторов и деструктора ( ClassName(); ~ClassName(); );
//										3. заголовки перегрузок операторов (+ - * / = > <; ++ -- << >>);
//										4. заголовки методов класса (void setField(type _variableName); void getField(void); );
// ClassName.cpp - реализация класса. В нем содержатся тела конструкторов, деструктора, методов и операторов. (Исполняемый код)
// Обязательный минимум в проетируемом классе:
//										1. Конструктор по умолчанию ClassName() {}
//										2. Конструктор копирования ClassName(ClassName const &copy) {}
//										3. Деструктор ~ClassName() {};
//										4. Оператор присваивания ClassName & operator=(ClassName &equal) {}

#ifndef CLASSTEMPLATE_HPP			 // в заголовочном файле не забываем писать защиту от повторного включения
#define CLASSTEMPLATE_HPP

#include <iostream>					 // Нужные заголовочные файлы указываем в *.hpp
#include <string>					 // В *.cpp в #include указываем только "ClassName.hpp" (в двойных кавычках)

using namespace std;				 // По необходимости включаем диретиву using

class ClassTemplate {										// Имя класса должно совпадать с именем файла
private:													// В полях класса модификаторы используют либо private, либо protected (если планируется наследование)
	int fieldInt;											// В нем перечисляем необходимые переменные любых типов 
	std::string fieldStr;
//	void privateMethod(void);								// и методы которые не должны напрямую быть доступными пользователю
public:														// Классы в С++ по умолчанию приватные
	ClassTemplate(): fieldInt(42), fieldStr("Ecole") {};										// Коснтруктор по умолчанию. Он может быть без тела. Если обратиться к полям обЪекта без предварительной инициализации, то получишь мусор в переменных или словишь сегу
//	СlassTemplate(int _fieldInt, std::string _fieldStr);	// Конструктор принимающий параметры при создании обЪекта
	ClassTemplate(int _fieldInt);							// Не обязательно прописывать все поля. Может быть с телом и без. В теле можно инициализировать другие переменные класса фиксированными значениями
//	ClassTemplate(): fieldInt(42), fieldStr("String") {};	// Конструктор по умолчанию со списком по умолчанию. Может быть с телом и без него. Может принимать параметры. Ниже два варианта с телом или без:
//	ClassTemplate(int _fieldInt, std::string _fieldStr): fieldInt(_fieldInt), fieldStr(_fieldStr) {}; или
	ClassTemplate(int _fieldInt, std::string _fieldStr); 
	ClassTemplate(const ClassTemplate &copy);				// Конструктор копирования, нужен для того чтобы инициализировать объект другим объектом. В теле пишется присвоение всех полей с помощью геттеров и сеттеров
	~ClassTemplate();										// Деструктор по умолчанию. Деструктор указывается только один, он может быть с телом, если в классе где то выделяется динамическая память либо без него. Вызывается компилятором

	ClassTemplate & operator=(const ClassTemplate &equal);		// Оператор присваивания для случаев когда объекты одного типа присваевается друг к другу (a = b). В теле обязательно писать проверку для случая объект равен самому себе (a = a)

	void setFieldInt(int _fieldInt);						// методы для обращения к полям класса с модификатором private и protected для изменения значения
	void setFieldStr(std::string _fieldStr);						// к каждому полю отдельно. В теле могут быть преобразования и защиты чтобы данные были валидными

	int getFieldInt(void) const;									// методы для обращения к полям класса с модификатором private и protected для извлечения данных
	std::string getFieldStr(void) const;							// к каждому полю отдельно
};
	std::ostream &operator<<(std::ostream &op,
							const ClassTemplate &_print);	// Перегрузка оператора << чтобы выводить объект созданного класса в cout

#endif
